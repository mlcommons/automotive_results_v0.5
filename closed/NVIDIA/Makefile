# Copyright (c) 2025, NVIDIA CORPORATION.  All rights reserved.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#	 http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

# This file is the main entrypoint of NVIDIA's MLPerf Inference codebase, and includes all of the other Makefiles used
# in the project.
# This file contains the targets used to run the actual MLPerf Inference workloads, as well as some basic utility
# commands.

MAKEFILE_NAME := $(lastword $(MAKEFILE_LIST))  # Must be declared before includes
include $(CURDIR)/Makefile.const
include $(CURDIR)/Makefile.docker
include $(CURDIR)/Makefile.build
include $(CURDIR)/Makefile.data
include $(CURDIR)/Makefile.submission

# Generate TensorRT engines (plan files) and run the harness.
.PHONY: run
run:
	@$(MAKE) -f $(MAKEFILE_NAME) generate_engines
	@$(MAKE) -f $(MAKEFILE_NAME) run_harness

# Generate TensorRT engines (plan files).
.PHONY: generate_engines
generate_engines: link_dirs
	@$(PYTHON3_CMD) -m code.main $(RUN_ARGS) --action="generate_engines"

.PHONY: generate_conf_files
generate_conf_files:
	@$(PYTHON3_CMD) -m code.main $(RUN_ARGS) --action="generate_conf_files"

# Run the harness and check accuracy if in AccuracyOnly mode.
# Add "set -o pipefail" so that "<command> | tee output.txt" will fail when "<command>" fails because otherwise tee
# would return status 0 and clear the failure status.
.PHONY: run_harness
run_harness: link_dirs
	@mkdir -p $(LOG_DIR)
	@set -o pipefail && LD_LIBRARY_PATH=$(HARNESS_LD_LIBRARY_PATH) $(PYTHON3_CMD) -m code.main $(RUN_ARGS) --action="run_harness" 2>&1 | tee $(LOG_DIR)/stdout.txt
	@set -o pipefail && $(PYTHON3_CMD) -m scripts.print_harness_result $(RUN_ARGS) 2>&1 | tee -a $(LOG_DIR)/stdout.txt

.PHONY: run_audit_harness
run_audit_harness: link_dirs
	@$(MAKE) -f $(MAKEFILE_NAME) run_audit_test01
	@$(MAKE) -f $(MAKEFILE_NAME) run_audit_test04

.PHONY: run_audit_test01_once
run_audit_test01_once: link_dirs
	@LD_LIBRARY_PATH=$(HARNESS_LD_LIBRARY_PATH) $(PYTHON3_CMD) -m code.main $(RUN_ARGS) --audit_test=TEST01 --action="run_audit_harness"

# TEST01 is sometimes unstable. Try up to two times before failing.
.PHONY: run_audit_test01
run_audit_test01:
	@for i in 1 2; do echo "TEST01 trial $$i" && $(MAKE) -f $(MAKEFILE_NAME) run_audit_test01_once && break; done

.PHONY: run_audit_test04_once
run_audit_test04_once: link_dirs
	@echo "Sleep to reset thermal state before TEST04..." && sleep 20
	@LD_LIBRARY_PATH=$(HARNESS_LD_LIBRARY_PATH) $(PYTHON3_CMD) -m code.main $(RUN_ARGS) --audit_test=TEST04 --action="run_audit_harness"

# TEST04 is so short that it is sometimes unstable. Try up to three times before failing.
.PHONY: run_audit_test04
run_audit_test04:
	@for i in 1 2 3; do echo "TEST04 trial $$i" && $(MAKE) -f $(MAKEFILE_NAME) run_audit_test04_once && break; done

# MLPerf Automotive v0.5 doesn't have LLM so no need to run test06
# .PHONY: run_audit_test06
# run_audit_test06: link_dirs
# 	@LD_LIBRARY_PATH=$(HARNESS_LD_LIBRARY_PATH) $(PYTHON3_CMD) -m code.main $(RUN_ARGS) --audit_test=TEST06 --action="run_audit_harness"

# Re-generate TensorRT calibration cache.
.PHONY: calibrate
calibrate: link_dirs
	@$(PYTHON3_CMD) -m code.main $(RUN_ARGS) --action="calibrate"


############################## UTILITY ##############################

# Remove build directory.
.PHONY: clean
clean: clean_shallow
	rm -rf build


# Remove only the files necessary for a clean build.
.PHONY: clean_shallow
clean_shallow:
	rm -rf build/bin
	rm -rf build/harness
	rm -rf build/plugins
	rm -rf $(TRTLLM_DIR)
	rm -rf $(LOADGEN_LIB_DIR)


# Print out useful information.
.PHONY: info
info:
	@echo "==== MLPerf Automotive:"
	@echo "VERSION=$(VERSION)"
	# @echo "PARTNER_DROP=$(PARTNER_DROP)"
	# @echo "PARTNER_RELEASE=$(PARTNER_RELEASE)"
	@echo "==== System:"
	@echo "RUN_ID=$(RUN_ID)"
	@echo "SYSTEM_NAME=$(shell $(PYTHON3_CMD) -m scripts.get_system_id 2> /dev/null)"
	@echo "Architecture=$(ARCH)"
	@echo "IS_SOC=$(IS_SOC)"
ifeq ($(IS_SOC), 1)
	@echo "SOC_SM=$(SOC_SM)"
else
	@echo "SM=$(SM)"
endif
	@echo "MIG_CONF=$(MIG_CONF)"
	@echo "==== Docker: "
	@echo "User=$(UNAME)"
	@echo "UID=$(UID)"
	@echo "HOSTNAME=$(HOSTNAME)"
	@echo "Usergroup=$(GROUPNAME)"
	@echo "GroupID=$(GROUPID)"
	@echo "UBUNTU_VERSION=$(UBUNTU_VERSION)"
	@echo "Docker info: {DETACH=$(DOCKER_DETACH), TAG=$(DOCKER_TAG)}"
	@echo "Docker file name: $(DOCKER_FILENAME)"
	@echo "Docker base image used: $(BASE_IMAGE_NAME)"
	@echo "Docker container registry used: $(CONTAINER_REGISTRY)"
	@echo "==== Env Vars:"
	@echo "PYTHON3_CMD=$(PYTHON3_CMD)"
	@echo "GIT_BIN"=$(GIT_BIN)
	@echo "PATH=$(PATH)"
	@echo "CPATH=$(CPATH)"
	@echo "CUDA_PATH=$(CUDA_PATH)"
	@echo "LIBRARY_PATH=$(LIBRARY_PATH)"
	@echo "LD_LIBRARY_PATH=$(LD_LIBRARY_PATH)"
	@echo "HARNESS_LD_LIBRARY_PATH=$(HARNESS_LD_LIBRARY_PATH)"
	@echo "EXTERNAL_USER=$(EXTERNAL_USER)"
	@echo "==== SW:"
	@echo "NVCC_CUDA_VER=$(CUDA_VER), (Detected: $(shell nvcc --version | grep "release" | awk '{print $$6}' | cut -d V -f 2))"
	@echo "DRIVER_VER=$(DRIVER_VER)"
	@echo "DRIVER_VER_MAJOR=$(DRIVER_VER_MAJOR)"
	@echo "TRT_VER=$(TRT_VER), (Detected: $(shell python -c "import tensorrt; print(tensorrt.__version__)"))"
	@echo "CUDNN_VER=$(CUDNN_VER), (Detected: $(shell dpkg -l | grep libcudnn8-dev | awk '{print $$3}' | cut -d'-' -f 1))"
	@echo "TORCH_VER=(Detected: $(shell python -c "import torch; print(torch.__version__)"))"
	@echo "==== Build flags:"
	@echo "HARNESS_BUILD_FLAGS=$(HARNESS_BUILD_FLAGS)"
	@echo "USE_NIGHTLY=$(USE_NIGHTLY)"



# The shell target will start a shell that inherits all the environment
# variables set by this Makefile for convenience.
.PHONY: shell
shell:
	@$(SHELL)

